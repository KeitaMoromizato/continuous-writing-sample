# はじめに
Webメディアの執筆作業に継続的インテグレーション(Continuous Integration)、継続的デリバリー(Continuous Delivery)の考えを取り入れ、GitHub/CircleCIを使って効率化をした話です。最初の環境構築さえしてしまえば、非エンジニアでも問題なくこの仕組みに乗ることが出来ています。これらのツールは発想次第でいろいろな使い方ができるということを、メディアの運営者やエンジニアに限らずいろいろな人に知って頂ければ良いのかなと。

# 背景
筆者は[SELECK](https://seleck.cc/top)というWebメディアで、エンジニア兼ライター(兼たまに編集)をしています。

SELECKでは主にスタートアップ界隈の人たちに「業務上でどういったソリューションを使っているか？」「どういった使い方をしているのか？」といった話をインタビューしています。その中で、CircleCIで完璧に自動化してるよ、とかGitHub Issueを使って営業の人達も一緒にディスカッションしてるよ、といった面白い話が聞ける訳です。

そんな中で弊社の開発環境はというと、まだ立ちあげ初期の段階ということもあり取材先企業ほど成熟してはいません。ですが、そのようなメディアを運営している以上は負けていられないので、取材した内容をいろいろと参考に改善を続けています。

その中で、記事執筆フローの改善を試みました。記事執筆には、書いた記事をどう保管するのか、編集者の修正を執筆者にフィードバックするにはどうするのか、という課題がありました。その問題を解決するため、Github/CircleCIを活用した記事運用フローを考案し、試してみました。

# やったこと
## 運用その(1) GitHubで記事を管理する
手始めに、記事をGitHubで管理することにしました。以前はGoogle Documentで共有して執筆・編集をしていましたが、それでは編集前後の差分が分かり辛く、執筆者へのフィードバックが困難でした。そこで差分管理＋共有がしたい、それならGitHubだよね、ということで記事専用レポジトリを作成して使い始めました。

もちろん運用するにあたりブランチの運用フローを決めるわけですが、ここで特徴的なのは**Git FlowおよびGitHub Flowには全く従っていない**ということです。**執筆者はガンガンmasterにコミットします。**

もちろん理由があり、先ほど述べたとおりGitHub活用の主目的を「編集前・後の差分を分かりやすく残していくこと」としています。そのため執筆時点での差分はさほど重要ではなく、masterがクリーンである必要性もありません。1記事を複数人で書くことも無いので、基本的にコンフリクトも起きません。そういう訳で、「執筆完了した時点でGitHubに記事が登録されている」という点だけ守れば、いつ記事を作成してもいいし、何度masterにコミットしてもOKというフローにしています。

![4.png](https://qiita-image-store.s3.amazonaws.com/0/52054/d755792c-9667-38c5-8dfc-ea691f2bdcc1.png)

編集のフローに入るため、執筆者が書き終えた段階でPull Requestを作成します。編集者はそのプルリク上で記事を編集し、記事が完成したらプルリクをマージします。このフローにすることで、編集前・後の差分をプルリクエスト単位でキレイに残すことが出来るのです。

ちなみに現時点では、執筆した記事の登録や編集作業はすべてGitHubのサイト上で行っているため、作業者はgitのコマンドを叩いたりする必要はありません。1ファイル単位での変更ならweb上でも意外と問題なく出来てしまうものです。このフローがいい感じに回り始めたらElectronで専用クライアント作ってみたいですね。

## 運用その(2) CircleCIで記事の品質を評価する
取材をしていると、昨今のモダンな開発組織では当たり前のようにCircleCIを活用し、自動でテストやLint、CodeClimateを使った品質の確保などを行っています。そんな話を聞いていて、ふと「これって記事にも使えるんじゃないの？」という声が降ってきました。記事もコードも同じテキストファイル。静的解析が出来ないわけないじゃないかと。

というわけで、CircleCIを使ってPull Requestが作られた記事に対して以下のチェックを行っています。ちなみにここではCIでテストをFailedにするのではなく、チェック内容をAPI経由でIssueにコメントするだけとしています。メディアの特性にもよりますが、インタビュー記事だと特に「文章が崩れているのも正解」というケースがあり、表現の自由度を担保するためにそうしています。

![5.png](https://qiita-image-store.s3.amazonaws.com/0/52054/0ffc8331-bee3-6d5e-de71-23e276d4b6fc.png)

CircleCIでは以下のようなメトリクスをチェックしています。どのようにチェックをしているのかは、本記事の最後に載せているレポジトリを参照してください(リファクタリングしてないのでコードの品質については。。)。

### 全体の文字数、タイトル・見出しの文字数
記事本文の文字数は目安として〇〇文字くらいというものが決まっているので、書いた記事が長いのか短いのかを自覚してもらう目的です。とは言え雰囲気で分かる部分でもあるので、それほど重要視はしていないです。重要なのはタイトル・見出しの文字数。特にタイトルはSNS/ポータル上でのアイキャッチとなるため、文字数に強い縛りを設けています。文字数に気をつけていても、執筆中や編集中についうっかりオーバーしてしまうため、CIで自動的に警告を出すようにしています。

CIのチェックが完了すると、以下の画像のようにPull Request上にコメントが流れます。自分のtokenでAPIを叩いているので自作自演っぽいですがbotですw

![2.png](https://qiita-image-store.s3.amazonaws.com/0/52054/2e5491c8-97a3-17d5-3736-3cb94591cdda.png)

### [Yahoo! 校正支援API](http://developer.yahoo.co.jp/webapi/jlp/kousei/v1/kousei.html)を使った自動校正

機械で判定できるエラーは人間がチェックする必要がない、というコードレビューにも通じる話です。自動校正で指摘された箇所は最低限直してから編集に入ります。また、編集中に誤って誤字ってしまった事にも気付けます。メディア御用達である「共同通信社 記者ハンドブック」を元にしているらしく、体感としては結構役に立っています。

次のようにPull Requsetのコメントに表として出力しています。

![3.png](https://qiita-image-store.s3.amazonaws.com/0/52054/540f267b-5c00-8c2c-23e0-fb30fa759ef4.png)

結構優秀な校正なのですが、メディアの性質によっては不要なワードもあります(WEB -> ウェブ など)。不要なものが毎度出てきても意味が無いので、フィルタリング機能を実装しました。簡単なJSON形式のファイルをレポジトリに含めており、エンジニア以外でも追加・変更ができる構成になっています。

### [Yahoo! キーフレーズ抽出API](http://developer.yahoo.co.jp/webapi/jlp/keyphrase/v1/extract.html)を使ったキーワード抽出

キーワードを抽出すること自体には大した意味はありませんが、記事内での単語出現回数を可視化するために使用しています。SELECKでは「一つの章で、ある単語が3回以上出現している」場合に警告を出す仕組みにしています。同じ言葉が繰り返される記事は冗長に見えるため、3回以上出現している場合は別の表現に言い換えましょう、という目安として使用しています。

## 運用その(3) CircleCIでWord形式にエクスポートする
最後に、編集が終わるとMarkdown形式の記事をMicrosoft Word形式に変換し、指定した場所にエクスポートするようにしています。完成した記事をインタビュー先企業に送るためにはWord形式にする必要が有るためです。Markdownが世界標準になってくれれば良いんですけどね。この機能はPull Requestがmasterにマージされたことを契機として動きます。

実はシステム的にはここが一番面倒でした。実現したかったのは「Pull Requestがマージされたタイミングで、そのPRで編集した記事をWord形式でExportする」ということ。一般的な継続的デリバリーの文脈では、masterにコミットされた(= マージされた)ときにまるっとデプロイするというケースが多いです。ただし今回は「マージされた時の差分ファイルだけデプロイ(= export)したい」「前述のとおり、執筆中はPull Requestを通さずにmasterに直接コミットされる」という開発ではあまり見かけないレアケースです。幸い前者はCircleCIの環境変数でコミットハッシュが取れるので難しくなかったですが、後者がCircleCIだけでは判定が厳しい。エンジニアとしては残念な回答になりますが、最終的にはコミットコメントに`Merge pull request #`が含まれているかを見ることにしました...

```js:ちょっと残念なコード
const isPullRequestMerged = data.commit.message.indexOf('Merge pull request #') !== -1;
```

## おまけ Chrome Extensionの活用
上記のフロートは関係は薄いですが、記事執筆に役立つChrome Extensionを書きました。[chrome-text-counter](https://chrome.google.com/webstore/detail/chrome-text-counter/ligmilmbglhaeialdpcbcgalhabhlepa?hl=ja)というもので、Chrome上でテキストを選択したときに、右上にフワッと選択された文字数が出るものです。

![1.png](https://qiita-image-store.s3.amazonaws.com/0/52054/9e7705e7-09eb-4201-f0fa-11f55ca714cb.png)

これはGitHubで記事を執筆・編集する上で出た要望を元に作りました。CIでも文字数はカウントしていますが、編集を時にも文字数をカウントしたいという要望を受けたので作りました。Chrome Webストアにもすでに類似するExtensionはありましたが、そのどれもがテキストを選択した後にワンアクション(右クリックなど)が必要なもので、記事を書くスピード感には合わないものでした。

コード量的には10行程度の簡単なものですが、個人的には気に入っています。
https://github.com/KeitaMoromizato/chrome-text-counter

# おわりに
大手メディアでは自動校正ツールを自作しているという話も聞きますが、この方法なら駆け出しのメディアでも工夫次第で記事のクオリティアップ、作業の効率化ができるのではないかと思います。Qiitaのような場に技術文章を書いている人も試してみると良いのではないでしょうか。

まあそんな難しい話よりも、作ってて楽しかったです。開発系のCI/CDは結構テンプレ化してきている点も多く、ワクワクが少ないんですよね。視野を開発から少し広げるだけで自動化できる事はまだまだあり、そこはアイデアがダイレクトに活きる領域です。皆さんも[SELECK](https://seleck.cc/top)で各社のソリューション活用事例を学んでみませんか？(宣伝)

# 参考
以下のレポジトリに今回のコードを置いています。実際に使っている環境から切り離しただけで、まだ汎用的に作れていないのですが参考までに。
https://github.com/KeitaMoromizato/continuous-writing
